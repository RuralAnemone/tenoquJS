const Request = require('request')
const Ws = require('ws')

const Tenoqu = {}

Tenoqu.bot = class Bot {
  constructor(config) {
    if (!config.prefix) config.prefix = '!'
    if (!config.token) throw new Error('Token Required')
    this.token = config.token
    this.prefix = config.prefix
    this.help = config.help == false ? config.help : true
    this.listeners = { listen: undefined, message: undefined, command: undefined, kill: undefined }
    this.commands = {}
    this.listenerWS = []
    this.awaiting = {}
    this.listen = (cb) => {
      if (cb) this.on('listen', cb)
      var fire = this.fire
      var saa = this
      var listen = Request({ url: 'https://tenoqu.xyz/api/v1/bot/listen/', method: 'POST', headers: { Authorization: 'bot@' + this.token }, json: true, body: { token: saa.token } })
      listen.on('response', function (res) {
        var a = []
        res.on('data', e => a.push(e)).on('end', () => {
          var Text = JSON.parse(Buffer.concat(a).toString())
          if (res.statusCode == 200) {
            saa.user = Text.user.replace(" <span class='bot-tag'>BOT &nbsp;✓</span>", '').replace("<span class='bot-tag'>BOT &nbsp;✓</span>", '')
            saa.realName = Text.user
            saa.id = Text.uid
            saa.icon = Text.icon
            fire('listen')
          } else {
            throw new Error(JSON.stringify(Text))
          }
        })
      })
      setInterval(() => {
        //always on server
      }, 100000)
    }
    this.fire = (event, data) => {
      if (this.listeners[event]) this.listeners[event].forEach(e => e(data ? data : null))
    }
    this.on = (event, cb) => {
      var saaa = this
      if (event == 'message') {
        var listener = new Ws('wss://tenoqu.xyz/message-listener', { headers: { Authorization: 'bot@' + this.token } })
        listener.on('open', () => {
          listener.on('message', (e) => {
            e = JSON.parse(e.toString())
            if (e.uid === saaa.id) return
            if (e.type == 'messagedone') {
              return saaa.awaiting[e.id.toString()] = false
            }
            e.channel.send = function (me) {
              var mid = Math.floor(Math.random() * (999999999999 - 100000000000) + 100000000000); listener.send(JSON.stringify({ author: saaa.realName, uid: saaa.id, 'hash': saaa.hash, 'content': me, timestamp: new Date().getTime(), bot: true, server: true, icon: saaa.icon, channel: e.channel.id, id: mid })); saaa.awaiting[mid] = true; return (new Promise((r, e) => {
                setInterval(() => {
                  if (saaa.awaiting[mid] == false) return r()
                }, 100)
              }))
            }
            saaa.fire('message', e)
          })
        })
      }
      if (event.startsWith('command@')) {
        var cei = event.split('command@')[1]
        if (cei == 'help' && this.commands[cei]) {
          if (this.help == true) throw new Error('Help Command Cannot Be Overriden. Please set the following: `help: false` in Your Configuration.')
        }
        this.commands[cei] = ''
        var listener = new Ws('wss://tenoqu.xyz/message-listener', { headers: { Authorization: 'bot@' + this.token } })
        listener.index = saaa.listenerWS.length + 1
        saaa.listenerWS.push(listener)
        listener.on('open', () => {
          listener.on('message', (e) => {
            var channelSend = null;
            e = JSON.parse(e.toString())
            if (e.type == 'messagedone') {
              return saaa.awaiting[e.id.toString()] = false
            }
            if (e.uid === saaa.id) return;
            if (!e.data) e.data = e
            if (e.data.content.startsWith(saaa.prefix + event.split('command@')[1])) {
              var params = e.data.content.split(' ')
              params.splice(0, 1)
              e.channel.send = function (me) {
                var mid = Math.floor(Math.random() * (999999999999 - 100000000000) + 100000000000);
                var timestamp = new Date().getTime(); listener.send(JSON.stringify({ author: saaa.realName, uid: saaa.id, 'hash': saaa.hash, 'content': me, timestamp: timestamp, bot: true, server: true, icon: saaa.icon, channel: e.channel.id, id: mid })); saaa.awaiting[mid] = true; return (new Promise((r, c) => {
                  setInterval(() => {
                    if (saaa.awaiting[mid] == false) { var obj = { author: saaa.realName, uid: saaa.id, 'hash': saaa.hash, 'content': me, timestamp: timestamp, bot: true, server: true, icon: saaa.icon, channel: e.channel.id, id: mid }; obj.channel.send = e.channel.send; return r(obj) }
                  }, 100)
                }))
              }
              channelSend = e.channel.send
              cb.apply({}, [e, ...params])
            }
            return null
          })
        })
      }
      if (!this.listeners[event]) {
        this.listeners[event] = [cb]
      } else {
        this.listeners[event].push(cb)
      }
    }
    this.kill = () => {

    }
    this.help = (command, desc) => {
      if (typeof command == 'object' && typeof desc !== 'object') {
        command.forEach(e => {
          this.commands[e] = desc
        })
      }
      if (typeof command == 'object' && typeof desc == 'object') {
        command.forEach(e => {
          var ind = command.indexOf(e)
          this.commands[e] = desc[ind]
        })
      }
      if (typeof command !== 'object' && typeof desc == 'object') throw new Error('If Description is an Object, The Command Must Follow The Same Path.')
      this.commands[command] = desc
    }
    this.on('command@help', (message, p1) => {
      if (p1) {

      } else {
        message.channel.send(`
Help:<br><br>
${Object.entries(this.commands).map(([v, e]) => `${v}: ${e == '' ? v == 'help' ? 'Shows This Command' : 'No Description available' : e}`).join('<br>')}
`)
      }
    })
  }
  get channels() {
    return {
      get: this.get
    }
  }
  get get() {
    return (id, config) => {
      id = [id]
      var saaa = this
      return new Promise((s, f) => {
        setTimeout(() => {
          var a = []
          var req = Request({ url: 'https://tenoqu.xyz/api/v1/bot/channels/' + id+(config.limit?'?limit='+config.limit:null), method: 'GET', headers: { Authorization: 'bot@' + this.token } }).on('response', (res) => {
            res.on('data', e => a.push(e)).on('end', () => {
              if (res.statusCode !== 200) {
                return f('Channel Fetch Error: Channel ' + id + ' Not Found. StatusCode: ' + res.statusCode)
              }
              var str = JSON.parse(Buffer.concat(a).toString())
              str.send = function (me) {
                var mid = Math.floor(Math.random() * (999999999999 - 100000000000) + 100000000000);
                var timestamp = new Date().getTime(); saaa.listenerWS.forEach(listener => listener.index == 1 ? listener.send(JSON.stringify({ author: saaa.realName, uid: saaa.id, 'hash': saaa.hash, 'content': me, timestamp: timestamp, bot: true, server: true, icon: saaa.icon, channel: id, id: mid })) : null); saaa.awaiting[mid] = true; return (new Promise((r, c) => {
                  setInterval(() => {
                    if (saaa.awaiting[mid] == false) { var obj = { author: saaa.realName, uid: saaa.id, 'hash': saaa.hash, 'content': me, timestamp: timestamp, bot: true, server: true, icon: saaa.icon, channel: id, id: mid }; obj.channel.send = str.send; return r(obj) }
                  }, 100)
                }))
              }
              var messages = str.messages
              delete str.messages
              str.messages = 'GETTER'
              Object.defineProperty(str, 'messages', {
                get() {
                  return messages
                },
                set(vl) {
                  return messages = vl
                }
              })
              return s(str)
            })
          })
        }, 300)
      })
    }
  }
}

module.exports = Tenoqu
